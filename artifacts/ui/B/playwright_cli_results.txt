time="2026-02-03T14:35:17Z" level=warning msg="/home/ubuntu/matchlab/docker-compose.dev.yml: `version` is obsolete"
============================= test session starts ==============================
platform linux -- Python 3.12.12, pytest-8.4.2, pluggy-1.6.0
django: version: 6.0.1, settings: config.settings (from env)
rootdir: /app
configfile: pytest.ini
plugins: django-4.11.1, base-url-2.1.0, playwright-0.7.2
collected 3 items

playwright_tests/tests/test_admin_match_results.py EEEEEE                [100%]

==================================== ERRORS ====================================
_ ERROR at setup of test_admin_match_results_page_displays_correctly[chromium] _

db = None

    @pytest.fixture
    def admin_user(db):
        """Create admin user for tests."""
>       user = User.objects.create_user(
            username="admin",
            email="admin@test.com",
            password="testpass123",
            is_staff=True,
            is_superuser=True,
        )

playwright_tests/conftest.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.12/site-packages/django/contrib/auth/models.py:175: in create_user
    return self._create_user(username, email, password, **extra_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/contrib/auth/models.py:163: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.12/site-packages/django/contrib/auth/base_user.py:62: in save
    super().save(**kwargs)
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:874: in save
    self.save_base(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:966: in save_base
    updated = self._save_table(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:1167: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:1218: in _do_insert
    return manager._insert(
/usr/local/lib/python3.12/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/models/query.py:1918: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/models/sql/compiler.py:1923: in execute_sql
    with self.connection.cursor() as cursor:
         ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<DatabaseWrapper vendor='postgresql' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
>               raise SynchronousOnlyOperation(message)
E               django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.

/usr/local/lib/python3.12/site-packages/django/utils/asyncio.py:24: SynchronousOnlyOperation
_ ERROR at teardown of test_admin_match_results_page_displays_correctly[chromium] _

request = <SubRequest '_django_db_helper' for <Function test_admin_match_results_page_displays_correctly[chromium]>>
django_db_setup = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x777040a95100>

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        with django_db_blocker.unblock():
            import django.db
            import django.test
    
            if transactional:
                test_case_class = django.test.TransactionTestCase
            else:
                test_case_class = django.test.TestCase
    
            _reset_sequences = reset_sequences
            _serialized_rollback = serialized_rollback
            _databases = databases
            _available_apps = available_apps
    
            class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
                reset_sequences = _reset_sequences
                serialized_rollback = _serialized_rollback
                if _databases is not None:
                    databases = _databases
                if _available_apps is not None:
                    available_apps = _available_apps
    
                # For non-transactional tests, skip executing `django.test.TestCase`'s
                # `setUpClass`/`tearDownClass`, only execute the super class ones.
                #
                # `TestCase`'s class setup manages the `setUpTestData`/class-level
                # transaction functionality. We don't use it; instead we (will) offer
                # our own alternatives. So it only adds overhead, and does some things
                # which conflict with our (planned) functionality, particularly, it
                # closes all database connections in `tearDownClass` which inhibits
                # wrapping tests in higher-scoped transactions.
                #
                # It's possible a new version of Django will add some unrelated
                # functionality to these methods, in which case skipping them completely
                # would not be desirable. Let's cross that bridge when we get there...
                if not transactional:
    
                    @classmethod
                    def setUpClass(cls) -> None:
                        super(django.test.TestCase, cls).setUpClass()
    
                    @classmethod
                    def tearDownClass(cls) -> None:
                        super(django.test.TestCase, cls).tearDownClass()
    
            PytestDjangoTestCase.setUpClass()
    
            test_case = PytestDjangoTestCase(methodName="__init__")
            test_case._pre_setup()
    
            yield
    
>           test_case._post_teardown()

/usr/local/lib/python3.12/site-packages/pytest_django/fixtures.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.12/site-packages/django/test/testcases.py:1240: in _post_teardown
    self._fixture_teardown()
/usr/local/lib/python3.12/site-packages/django/test/testcases.py:1275: in _fixture_teardown
    call_command(
/usr/local/lib/python3.12/site-packages/django/core/management/__init__.py:195: in call_command
    return command.execute(*args, **defaults)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/core/management/base.py:464: in execute
    output = self.handle(*args, **options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/core/management/commands/flush.py:52: in handle
    sql_list = sql_flush(
/usr/local/lib/python3.12/site-packages/django/core/management/sql.py:11: in sql_flush
    tables = connection.introspection.django_table_names(
/usr/local/lib/python3.12/site-packages/django/db/backends/base/introspection.py:113: in django_table_names
    existing_tables = set(self.table_names(include_views=include_views))
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/backends/base/introspection.py:59: in table_names
    with self.connection.cursor() as cursor:
         ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<DatabaseWrapper vendor='postgresql' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
>               raise SynchronousOnlyOperation(message)
E               django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.

/usr/local/lib/python3.12/site-packages/django/utils/asyncio.py:24: SynchronousOnlyOperation
______ ERROR at setup of test_admin_match_results_filters_work[chromium] _______

db = None

    @pytest.fixture
    def admin_user(db):
        """Create admin user for tests."""
>       user = User.objects.create_user(
            username="admin",
            email="admin@test.com",
            password="testpass123",
            is_staff=True,
            is_superuser=True,
        )

playwright_tests/conftest.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.12/site-packages/django/contrib/auth/models.py:175: in create_user
    return self._create_user(username, email, password, **extra_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/contrib/auth/models.py:163: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.12/site-packages/django/contrib/auth/base_user.py:62: in save
    super().save(**kwargs)
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:874: in save
    self.save_base(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:966: in save_base
    updated = self._save_table(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:1167: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:1218: in _do_insert
    return manager._insert(
/usr/local/lib/python3.12/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/models/query.py:1918: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/models/sql/compiler.py:1923: in execute_sql
    with self.connection.cursor() as cursor:
         ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<DatabaseWrapper vendor='postgresql' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
>               raise SynchronousOnlyOperation(message)
E               django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.

/usr/local/lib/python3.12/site-packages/django/utils/asyncio.py:24: SynchronousOnlyOperation
_____ ERROR at teardown of test_admin_match_results_filters_work[chromium] _____

request = <SubRequest '_django_db_helper' for <Function test_admin_match_results_filters_work[chromium]>>
django_db_setup = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x777040a95100>

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        with django_db_blocker.unblock():
            import django.db
            import django.test
    
            if transactional:
                test_case_class = django.test.TransactionTestCase
            else:
                test_case_class = django.test.TestCase
    
            _reset_sequences = reset_sequences
            _serialized_rollback = serialized_rollback
            _databases = databases
            _available_apps = available_apps
    
            class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
                reset_sequences = _reset_sequences
                serialized_rollback = _serialized_rollback
                if _databases is not None:
                    databases = _databases
                if _available_apps is not None:
                    available_apps = _available_apps
    
                # For non-transactional tests, skip executing `django.test.TestCase`'s
                # `setUpClass`/`tearDownClass`, only execute the super class ones.
                #
                # `TestCase`'s class setup manages the `setUpTestData`/class-level
                # transaction functionality. We don't use it; instead we (will) offer
                # our own alternatives. So it only adds overhead, and does some things
                # which conflict with our (planned) functionality, particularly, it
                # closes all database connections in `tearDownClass` which inhibits
                # wrapping tests in higher-scoped transactions.
                #
                # It's possible a new version of Django will add some unrelated
                # functionality to these methods, in which case skipping them completely
                # would not be desirable. Let's cross that bridge when we get there...
                if not transactional:
    
                    @classmethod
                    def setUpClass(cls) -> None:
                        super(django.test.TestCase, cls).setUpClass()
    
                    @classmethod
                    def tearDownClass(cls) -> None:
                        super(django.test.TestCase, cls).tearDownClass()
    
            PytestDjangoTestCase.setUpClass()
    
            test_case = PytestDjangoTestCase(methodName="__init__")
            test_case._pre_setup()
    
            yield
    
>           test_case._post_teardown()

/usr/local/lib/python3.12/site-packages/pytest_django/fixtures.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.12/site-packages/django/test/testcases.py:1240: in _post_teardown
    self._fixture_teardown()
/usr/local/lib/python3.12/site-packages/django/test/testcases.py:1275: in _fixture_teardown
    call_command(
/usr/local/lib/python3.12/site-packages/django/core/management/__init__.py:195: in call_command
    return command.execute(*args, **defaults)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/core/management/base.py:464: in execute
    output = self.handle(*args, **options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/core/management/commands/flush.py:52: in handle
    sql_list = sql_flush(
/usr/local/lib/python3.12/site-packages/django/core/management/sql.py:11: in sql_flush
    tables = connection.introspection.django_table_names(
/usr/local/lib/python3.12/site-packages/django/db/backends/base/introspection.py:113: in django_table_names
    existing_tables = set(self.table_names(include_views=include_views))
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/backends/base/introspection.py:59: in table_names
    with self.connection.cursor() as cursor:
         ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<DatabaseWrapper vendor='postgresql' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
>               raise SynchronousOnlyOperation(message)
E               django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.

/usr/local/lib/python3.12/site-packages/django/utils/asyncio.py:24: SynchronousOnlyOperation
_____ ERROR at setup of test_admin_match_results_export_options[chromium] ______

db = None

    @pytest.fixture
    def admin_user(db):
        """Create admin user for tests."""
>       user = User.objects.create_user(
            username="admin",
            email="admin@test.com",
            password="testpass123",
            is_staff=True,
            is_superuser=True,
        )

playwright_tests/conftest.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.12/site-packages/django/contrib/auth/models.py:175: in create_user
    return self._create_user(username, email, password, **extra_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/contrib/auth/models.py:163: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.12/site-packages/django/contrib/auth/base_user.py:62: in save
    super().save(**kwargs)
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:874: in save
    self.save_base(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:966: in save_base
    updated = self._save_table(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:1167: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.12/site-packages/django/db/models/base.py:1218: in _do_insert
    return manager._insert(
/usr/local/lib/python3.12/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/models/query.py:1918: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/models/sql/compiler.py:1923: in execute_sql
    with self.connection.cursor() as cursor:
         ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<DatabaseWrapper vendor='postgresql' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
>               raise SynchronousOnlyOperation(message)
E               django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.

/usr/local/lib/python3.12/site-packages/django/utils/asyncio.py:24: SynchronousOnlyOperation
____ ERROR at teardown of test_admin_match_results_export_options[chromium] ____

request = <SubRequest '_django_db_helper' for <Function test_admin_match_results_export_options[chromium]>>
django_db_setup = None
django_db_blocker = <pytest_django.plugin.DjangoDbBlocker object at 0x777040a95100>

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -> Generator[None, None, None]:
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        with django_db_blocker.unblock():
            import django.db
            import django.test
    
            if transactional:
                test_case_class = django.test.TransactionTestCase
            else:
                test_case_class = django.test.TestCase
    
            _reset_sequences = reset_sequences
            _serialized_rollback = serialized_rollback
            _databases = databases
            _available_apps = available_apps
    
            class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
                reset_sequences = _reset_sequences
                serialized_rollback = _serialized_rollback
                if _databases is not None:
                    databases = _databases
                if _available_apps is not None:
                    available_apps = _available_apps
    
                # For non-transactional tests, skip executing `django.test.TestCase`'s
                # `setUpClass`/`tearDownClass`, only execute the super class ones.
                #
                # `TestCase`'s class setup manages the `setUpTestData`/class-level
                # transaction functionality. We don't use it; instead we (will) offer
                # our own alternatives. So it only adds overhead, and does some things
                # which conflict with our (planned) functionality, particularly, it
                # closes all database connections in `tearDownClass` which inhibits
                # wrapping tests in higher-scoped transactions.
                #
                # It's possible a new version of Django will add some unrelated
                # functionality to these methods, in which case skipping them completely
                # would not be desirable. Let's cross that bridge when we get there...
                if not transactional:
    
                    @classmethod
                    def setUpClass(cls) -> None:
                        super(django.test.TestCase, cls).setUpClass()
    
                    @classmethod
                    def tearDownClass(cls) -> None:
                        super(django.test.TestCase, cls).tearDownClass()
    
            PytestDjangoTestCase.setUpClass()
    
            test_case = PytestDjangoTestCase(methodName="__init__")
            test_case._pre_setup()
    
            yield
    
>           test_case._post_teardown()

/usr/local/lib/python3.12/site-packages/pytest_django/fixtures.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.12/site-packages/django/test/testcases.py:1240: in _post_teardown
    self._fixture_teardown()
/usr/local/lib/python3.12/site-packages/django/test/testcases.py:1275: in _fixture_teardown
    call_command(
/usr/local/lib/python3.12/site-packages/django/core/management/__init__.py:195: in call_command
    return command.execute(*args, **defaults)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/core/management/base.py:464: in execute
    output = self.handle(*args, **options)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/core/management/commands/flush.py:52: in handle
    sql_list = sql_flush(
/usr/local/lib/python3.12/site-packages/django/core/management/sql.py:11: in sql_flush
    tables = connection.introspection.django_table_names(
/usr/local/lib/python3.12/site-packages/django/db/backends/base/introspection.py:113: in django_table_names
    existing_tables = set(self.table_names(include_views=include_views))
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.12/site-packages/django/db/backends/base/introspection.py:59: in table_names
    with self.connection.cursor() as cursor:
         ^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = (<DatabaseWrapper vendor='postgresql' alias='default'>,), kwargs = {}

    @wraps(func)
    def inner(*args, **kwargs):
        # Detect a running event loop in this thread.
        try:
            get_running_loop()
        except RuntimeError:
            pass
        else:
            if not os.environ.get("DJANGO_ALLOW_ASYNC_UNSAFE"):
>               raise SynchronousOnlyOperation(message)
E               django.core.exceptions.SynchronousOnlyOperation: You cannot call this from an async context - use a thread or sync_to_async.

/usr/local/lib/python3.12/site-packages/django/utils/asyncio.py:24: SynchronousOnlyOperation
=========================== short test summary info ============================
ERROR playwright_tests/tests/test_admin_match_results.py::test_admin_match_results_page_displays_correctly[chromium]
ERROR playwright_tests/tests/test_admin_match_results.py::test_admin_match_results_page_displays_correctly[chromium]
ERROR playwright_tests/tests/test_admin_match_results.py::test_admin_match_results_filters_work[chromium]
ERROR playwright_tests/tests/test_admin_match_results.py::test_admin_match_results_filters_work[chromium]
ERROR playwright_tests/tests/test_admin_match_results.py::test_admin_match_results_export_options[chromium]
ERROR playwright_tests/tests/test_admin_match_results.py::test_admin_match_results_export_options[chromium]
============================== 6 errors in 3.78s ===============================
